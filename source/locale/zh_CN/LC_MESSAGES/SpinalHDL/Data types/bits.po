
msgid ""
msgstr ""
"Project-Id-Version:SpinalHDLReport-Msgid-Bugs-To:POT-Creation-Date:2023-12-01 11:48+0800PO-Revision-Date:YEAR-MO-DA HO:MI+ZONELast-Translator:FULL NAME <EMAIL@ADDRESS>Language:zh_CNLanguage-Team:zh_CN <LL@li.org>Plural-Forms:nplurals=1; plural=0;MIME-Version:1.0Content-Type:text/plain; charset=UTF-8"
"Report-Msgid-Bugs-To:EMAIL@ADDRESS"
"POT-Creation-Date:2023-12-02 00:23+0800"
"PO-Revision-Date:YEAR-MO-DA HO:MI+ZONE"
"Last-Translator:FULL NAME <EMAIL@ADDRESS>"
"Language-Team:LANGUAGE <LL@li.org>"
"MIME-Version:1.0"
"Content-Type:text/plain; charset=UTF-8"
"Content-Transfer-Encoding:8bit"
"Generated-By:Babel 2.13.1"

#: ../../SpinalHDL/Data types/bits.rst:4
msgid "Bits"
msgstr "位"
#: ../../SpinalHDL/Data types/bits.rst:6
#, fuzzy
msgid ""
"The ``Bits`` type is a vector of bits without conveying any arithmetic "
"meaning."
msgstr "“Bits”类型是位向量，不传达任何算术含义。"
#: ../../SpinalHDL/Data types/bits.rst:9
msgid "Declaration"
msgstr "宣言"
#: ../../SpinalHDL/Data types/bits.rst:11
#, fuzzy
msgid ""
"The syntax to declare a bit vector is as follows (everything between [] is "
"optional):"
msgstr "声明位向量的语法如下（[]之间的所有内容都是可选的）："
#: ../../SpinalHDL/Data types/bits.rst:17
msgid "Syntax"
msgstr "句法"
#: ../../SpinalHDL/Data types/bits.rst:18 types/bits.rst:82 types/bits.rst:182
#: types/bits.rst:207 types/bits.rst:260 types/bits.rst:358
msgid "Description"
msgstr "描述"
#: ../../SpinalHDL/Data types/bits.rst:19
msgid "Bits [()]"
msgstr "位[()]"
#: ../../SpinalHDL/Data types/bits.rst:20
msgid ""
"Create Bits, bit count is inferred from the widest assignment statement "
"after construction"
msgstr "创建位，位计数是从构造后最宽的赋值语句推断出来的"
#: ../../SpinalHDL/Data types/bits.rst:22 types/bits.rst:393
msgid "Bits(x bits)"
msgstr "位数（x 位）"
#: ../../SpinalHDL/Data types/bits.rst:23
#, fuzzy
msgid "Create Bits with x bits"
msgstr "创建具有 x 位的位"
#: ../../SpinalHDL/Data types/bits.rst
msgid "B(value: Int[, x bits])"
msgstr "B(value: Int[, x bits])"
#: ../../SpinalHDL/Data types/bits.rst
msgid "B(value: BigInt[, x bits])"
msgstr "B(值: BigInt[, x 位])"
#: ../../SpinalHDL/Data types/bits.rst:26
#, fuzzy
msgid "Create Bits with x bits assigned with 'value'"
msgstr "创建位，其中 x 位分配有“值”"
#: ../../SpinalHDL/Data types/bits.rst:27
msgid "B\"[[size']base]value\""
msgstr "B\"[[size']base]值\""
#: ../../SpinalHDL/Data types/bits.rst:28
#, fuzzy
msgid "Create Bits assigned with 'value' (base: 'h', 'd', 'o', 'b')"
msgstr "创建分配有“value”的位（基数：“h”、“d”、“o”、“b”）"
#: ../../SpinalHDL/Data types/bits.rst:29
#, fuzzy
msgid "B([x bits,] elements: Element*)"
msgstr "B([x 位，] 元素：元素*)"
#: ../../SpinalHDL/Data types/bits.rst:30
#, fuzzy
msgid ""
"Create Bits assigned with the value specified by :ref:`elements <element>`"
msgstr "创建分配有由 :ref:`elements <element>` 指定的值的位"
#: ../../SpinalHDL/Data types/bits.rst:53
msgid ""
"When inferring the width of a ``Bits`` the sizes of assigned values still "
"have to match the final size of the signal:"
msgstr "当推断“位”的宽度时，分配值的大小仍然必须与信号的最终大小相匹配："
#: ../../SpinalHDL/Data types/bits.rst:70
msgid "Operators"
msgstr "运营商"
#: ../../SpinalHDL/Data types/bits.rst:72
msgid "The following operators are available for the ``Bits`` type:"
msgstr "以下运算符可用于“Bits”类型："
#: ../../SpinalHDL/Data types/bits.rst:75
msgid "Logic"
msgstr "逻辑"
#: ../../SpinalHDL/Data types/bits.rst:81 types/bits.rst:181
#: types/bits.rst:206 types/bits.rst:259 types/bits.rst:357
msgid "Operator"
msgstr "操作员"
#: ../../SpinalHDL/Data types/bits.rst:83 types/bits.rst:183
msgid "Return type"
msgstr "返回类型"
#: ../../SpinalHDL/Data types/bits.rst:84
msgid "~x"
msgstr "〜x"
#: ../../SpinalHDL/Data types/bits.rst:85
msgid "Bitwise NOT"
msgstr "按位非"
#: ../../SpinalHDL/Data types/bits.rst:86 types/bits.rst:114
#: types/bits.rst:128 types/bits.rst:132 types/bits.rst:136 types/bits.rst:140
#: types/bits.rst:211 types/bits.rst:226 types/bits.rst:374 types/bits.rst:389
msgid "Bits(w(x) bits)"
msgstr "位（w(x) 位）"
#: ../../SpinalHDL/Data types/bits.rst:87
msgid "x & y"
msgstr "坐标"
#: ../../SpinalHDL/Data types/bits.rst:88
msgid "Bitwise AND"
msgstr "按位与"
#: ../../SpinalHDL/Data types/bits.rst:89 types/bits.rst:92 types/bits.rst:95
msgid "Bits(w(xy) bits)"
msgstr "位（w(xy) 位）"
#: ../../SpinalHDL/Data types/bits.rst:90
msgid "x | y"
msgstr "x| y"
#: ../../SpinalHDL/Data types/bits.rst:91
msgid "Bitwise OR"
msgstr "按位或"
#: ../../SpinalHDL/Data types/bits.rst:93
msgid "x ^ y"
msgstr "x^y"
#: ../../SpinalHDL/Data types/bits.rst:94
msgid "Bitwise XOR"
msgstr "按位异或"
#: ../../SpinalHDL/Data types/bits.rst:96
msgid "x.xorR"
msgstr "异或R"
#: ../../SpinalHDL/Data types/bits.rst:97
msgid "XOR all bits of x"
msgstr "对 x 的所有位进行异或"
#: ../../SpinalHDL/Data types/bits.rst:98 types/bits.rst:101
#: types/bits.rst:104 types/bits.rst:186 types/bits.rst:189 types/bits.rst:264
#: types/bits.rst:267 types/bits.rst:285 types/bits.rst:288
msgid "Bool"
msgstr "布尔"
#: ../../SpinalHDL/Data types/bits.rst:99
msgid "x.orR"
msgstr "x或R"
#: ../../SpinalHDL/Data types/bits.rst:100
msgid "OR all bits of x"
msgstr "或 x 的所有位"
#: ../../SpinalHDL/Data types/bits.rst:102
msgid "x.andR"
msgstr "x和R"
#: ../../SpinalHDL/Data types/bits.rst:103
msgid "AND all bits of x"
msgstr "AND x 的所有位"
#: ../../SpinalHDL/Data types/bits.rst
msgid "y = 1 // Int"
msgstr "y = 1 // 整数"
#: ../../SpinalHDL/Data types/bits.rst
msgid "x \\>\\> y"
msgstr "x \\>\\> y"
#: ../../SpinalHDL/Data types/bits.rst
msgid "Logical shift right, y: Int"
msgstr "逻辑右移，y：Int"
#: ../../SpinalHDL/Data types/bits.rst
msgid "Result may reduce width"
msgstr "结果可能会减少宽度"
#: ../../SpinalHDL/Data types/bits.rst:109
msgid "Bits(w(x) - y bits)"
msgstr "位（w(x) - y 位）"
#: ../../SpinalHDL/Data types/bits.rst
msgid "y = U(1) // UInt"
msgstr "y = U(1) // UInt"
#: ../../SpinalHDL/Data types/bits.rst
msgid "Logical shift right, y: UInt"
msgstr "逻辑右移，y：UInt"
#: ../../SpinalHDL/Data types/bits.rst
msgid "Result is same width"
msgstr "结果宽度相同"
#: ../../SpinalHDL/Data types/bits.rst
msgid "x \\<\\< y"
msgstr "x \\<\\< y"
#: ../../SpinalHDL/Data types/bits.rst
msgid "Logical shift left, y: Int"
msgstr "逻辑左移，y：Int"
#: ../../SpinalHDL/Data types/bits.rst
msgid "Result may increase width"
msgstr "结果可能会增加宽度"
#: ../../SpinalHDL/Data types/bits.rst:119
msgid "Bits(w(x) + y bits)"
msgstr "位（w(x) + y 位）"
#: ../../SpinalHDL/Data types/bits.rst
msgid "Logical shift left, y: UInt"
msgstr "逻辑左移，y：UInt"
#: ../../SpinalHDL/Data types/bits.rst:124
msgid "Bits(w(x) + max(y) bits)"
msgstr "Bits(w(x) + max(y) bits)"
#: ../../SpinalHDL/Data types/bits.rst:125
msgid "x \\|\\>\\> y"
msgstr "x \\|\\>\\> y"
#: ../../SpinalHDL/Data types/bits.rst
msgid "Logical shift right, y: Int/UInt"
msgstr "逻辑右移，y：Int/UInt"
#: ../../SpinalHDL/Data types/bits.rst:129
msgid "x \\|\\<\\< y"
msgstr "x \\|\\<\\< y"
#: ../../SpinalHDL/Data types/bits.rst
msgid "Logical shift left, y: Int/UInt"
msgstr "逻辑左移，y：Int/UInt"
#: ../../SpinalHDL/Data types/bits.rst:133
msgid "x.rotateLeft(y)"
msgstr "x.向左旋转(y)"
#: ../../SpinalHDL/Data types/bits.rst
msgid "Logical left rotation, y: UInt/Int"
msgstr "逻辑左旋转，y：UInt/Int"
#: ../../SpinalHDL/Data types/bits.rst:137
msgid "x.rotateRight(y)"
msgstr "x.向右旋转(y)"
#: ../../SpinalHDL/Data types/bits.rst
msgid "Logical right rotation, y: UInt/Int"
msgstr "逻辑右旋转，y：UInt/Int"
#: ../../SpinalHDL/Data types/bits.rst:141
msgid "x.clearAll[()]"
msgstr "x.clearAll[()]"
#: ../../SpinalHDL/Data types/bits.rst:142
msgid "Clear all bits"
msgstr "清除所有位"
#: ../../SpinalHDL/Data types/bits.rst:143 types/bits.rst:146
#: types/bits.rst:149 types/bits.rst:152
msgid "*modifies x*"
msgstr "*修改x*"
#: ../../SpinalHDL/Data types/bits.rst:144
msgid "x.setAll[()]"
msgstr "x.setAll[()]"
#: ../../SpinalHDL/Data types/bits.rst:145
msgid "Set all bits"
msgstr "设置所有位"
#: ../../SpinalHDL/Data types/bits.rst:147
msgid "x.setAllTo(value: Boolean)"
msgstr "x.setAllTo(值：布尔值)"
#: ../../SpinalHDL/Data types/bits.rst:148
msgid "Set all bits to the given Boolean value"
msgstr "将所有位设置为给定的布尔值"
#: ../../SpinalHDL/Data types/bits.rst:150
msgid "x.setAllTo(value: Bool)"
msgstr "x.setAllTo(值: Bool)"
#: ../../SpinalHDL/Data types/bits.rst:151
msgid "Set all bits to the given Bool value"
msgstr "将所有位设置为给定的布尔值"
#: ../../SpinalHDL/Data types/bits.rst:176
msgid "Comparison"
msgstr "比较"
#: ../../SpinalHDL/Data types/bits.rst:184
msgid "x === y"
msgstr "x === y"
#: ../../SpinalHDL/Data types/bits.rst:185
msgid "Equality"
msgstr "平等"
#: ../../SpinalHDL/Data types/bits.rst:187
msgid "x =/= y"
msgstr "x =/= y"
#: ../../SpinalHDL/Data types/bits.rst:188
msgid "Inequality"
msgstr "不等式"
#: ../../SpinalHDL/Data types/bits.rst:201
msgid "Type cast"
msgstr "类型转换"
#: ../../SpinalHDL/Data types/bits.rst:208 types/bits.rst:261
#: types/bits.rst:359
msgid "Return"
msgstr "返回"
#: ../../SpinalHDL/Data types/bits.rst:209
msgid "x.asBits"
msgstr "x.asBits"
#: ../../SpinalHDL/Data types/bits.rst:210
msgid "Binary cast to Bits"
msgstr "二进制转换为 Bits"
#: ../../SpinalHDL/Data types/bits.rst:212
msgid "x.asUInt"
msgstr "x.asUIt"
#: ../../SpinalHDL/Data types/bits.rst:213
msgid "Binary cast to UInt"
msgstr "二进制转换为 UInt"
#: ../../SpinalHDL/Data types/bits.rst:214
msgid "UInt(w(x) bits)"
msgstr "UInt(w(x) 位)"
#: ../../SpinalHDL/Data types/bits.rst:215
msgid "x.asSInt"
msgstr "x.asSInt"
#: ../../SpinalHDL/Data types/bits.rst:216
msgid "Binary cast to SInt"
msgstr "Binary cast to SInt"
#: ../../SpinalHDL/Data types/bits.rst:217
msgid "SInt(w(x) bits)"
msgstr "SInt(w(x) 位)"
#: ../../SpinalHDL/Data types/bits.rst:218
msgid "x.asBools"
msgstr "x.asBools"
#: ../../SpinalHDL/Data types/bits.rst:219
msgid "Cast to an array of Bools"
msgstr "转换为布尔数组"
#: ../../SpinalHDL/Data types/bits.rst:220
msgid "Vec(Bool(), w(x))"
msgstr "Vec(布尔(), w(x))"
#: ../../SpinalHDL/Data types/bits.rst:221
#, fuzzy
msgid "x.asBool"
msgstr "x.asBool"
#: ../../SpinalHDL/Data types/bits.rst:222
msgid "Extract LSB of :code:`x`"
msgstr "提取 :code:`x` 的 LSB"
#: ../../SpinalHDL/Data types/bits.rst:223
#, fuzzy
msgid "Bool(x.lsb)"
msgstr "布尔值(x.lsb)"
#: ../../SpinalHDL/Data types/bits.rst:224
msgid "B(x: T)"
msgstr "B(x: T)"
#: ../../SpinalHDL/Data types/bits.rst:225
msgid "Cast Data to Bits"
msgstr "将数据转换为位"
#: ../../SpinalHDL/Data types/bits.rst:229
#, fuzzy
msgid ""
"To cast a ``Bool``, ``UInt`` or an ``SInt`` into a ``Bits``, you can use "
"``B(something)`` or ``B(something[, x bits])``:"
msgstr ""
"要将“Bool”、“UInt”或“SInt”转换为“Bits”，您可以使用“B(something)”或“B(something[, x 位” "
"])``:"
#: ../../SpinalHDL/Data types/bits.rst:247
msgid "Bit extraction"
msgstr "位提取"
#: ../../SpinalHDL/Data types/bits.rst:249
msgid ""
"All of the bit extraction operations can be used to read a bit / group of "
"bits. Like in other HDLs the extraction operators can also be used to assign"
" a part of a ``Bits``."
msgstr "所有位提取操作均可用于读取一个位/一组位。与其他 HDL 一样，提取运算符也可用于分配“位”的一部分。"
#: ../../SpinalHDL/Data types/bits.rst:252
msgid ""
"All of the bit extraction operations can be used to read a bit / group of "
"bits. Like in other HDLs They can also be used to select a range of bits to "
"be written."
msgstr "所有位提取操作均可用于读取一个位/一组位。与其他 HDL 一样，它们也可用于选择要写入的位范围。"
#: ../../SpinalHDL/Data types/bits.rst:262
#, fuzzy
msgid "x(y: Int)"
msgstr "x(y: 整数)"
#: ../../SpinalHDL/Data types/bits.rst:263
msgid "Static bit access of y-th bit"
msgstr "第 y 位的静态位访问"
#: ../../SpinalHDL/Data types/bits.rst:265
#, fuzzy
msgid "x(x: UInt)"
msgstr "x(x: UInt)"
#: ../../SpinalHDL/Data types/bits.rst:266
msgid "Variable bit access of y-th bit"
msgstr "第 y 位的可变位访问"
#: ../../SpinalHDL/Data types/bits.rst:268
#, fuzzy
msgid "x(offset: Int, width bits)"
msgstr "x（偏移量：Int，宽度位）"
#: ../../SpinalHDL/Data types/bits.rst:269
msgid "Fixed part select of fixed width, offset is LSB index"
msgstr "固定宽度的固定部分选择，偏移量为LSB索引"
#: ../../SpinalHDL/Data types/bits.rst:270 types/bits.rst:273
msgid "Bits(width bits)"
msgstr "位（宽度位）"
#: ../../SpinalHDL/Data types/bits.rst:271
#, fuzzy
msgid "x(offset: UInt, width bits)"
msgstr "x（偏移量：UInt，宽度位）"
#: ../../SpinalHDL/Data types/bits.rst:272
msgid "Variable part-select of fixed width, offset is LSB index"
msgstr "固定宽度的可变部分选择，偏移量为LSB索引"
#: ../../SpinalHDL/Data types/bits.rst:274
#, fuzzy
msgid "x(range: Range)"
msgstr "x(范围：范围)"
#: ../../SpinalHDL/Data types/bits.rst:275
#, fuzzy
msgid "Access a :ref:`range <range>` of bits. Ex : myBits(4 downto 2)"
msgstr "访问位的范围 <range>`。例如：myBits(4 降到 2)"
#: ../../SpinalHDL/Data types/bits.rst:276
#, fuzzy
msgid "Bits(range.size bits)"
msgstr "位(范围.大小位)"
#: ../../SpinalHDL/Data types/bits.rst:277
#, fuzzy
msgid "x.subdivideIn(y slices, [strict: Boolean])"
msgstr "x.subdivideIn(y 切片, [严格: 布尔值])"
#: ../../SpinalHDL/Data types/bits.rst:278
#, fuzzy
msgid "Subdivide x into y slices, y: Int"
msgstr "将x细分为y片，y：Int"
#: ../../SpinalHDL/Data types/bits.rst:279
#, fuzzy
msgid "Vec(Bits(...), y)"
msgstr "Vec(位(...), y)"
#: ../../SpinalHDL/Data types/bits.rst:280
#, fuzzy
msgid "x.subdivideIn(y bits, [strict: Boolean])"
msgstr "x.subdivideIn(y 位，[严格：布尔值])"
#: ../../SpinalHDL/Data types/bits.rst:281
msgid "Subdivide x in multiple slices of y bits, y: Int"
msgstr "将 x 细分为 y 位的多个切片，y: Int"
#: ../../SpinalHDL/Data types/bits.rst:282
#, fuzzy
msgid "Vec(Bits(y bit), ...)"
msgstr "Vec(位(y 位), ...)"
#: ../../SpinalHDL/Data types/bits.rst:283
msgid "x.msb"
msgstr "x.msb"
#: ../../SpinalHDL/Data types/bits.rst:284
msgid "Access most significant bit of x (highest index)"
msgstr "访问 x 的最高有效位（最高索引）"
#: ../../SpinalHDL/Data types/bits.rst:286
msgid "x.lsb"
msgstr "x.lsb"
#: ../../SpinalHDL/Data types/bits.rst:287
msgid "Access lowest significant bit of x (index 0)"
msgstr "访问 x 的最低有效位（索引 0）"
#: ../../SpinalHDL/Data types/bits.rst:291
msgid "Some basic examples:"
msgstr "一些基本示例："
#: ../../SpinalHDL/Data types/bits.rst:320
msgid "Subdivide details"
msgstr "细分细节"
#: ../../SpinalHDL/Data types/bits.rst:322
msgid ""
"Both overloads of ``subdivideIn`` have an optional parameter ``strict`` "
"(i.e. ``subdivideIn(slices: SlicesCount, strict: Boolean = true)``). If "
"``strict`` is ``true`` an error will be raised if the input could not be "
"divided into equal parts. If set to ``false`` the last element may be "
"smaller than the other (equal sized) elements."
msgstr ""
"``subdivideIn`` 的两个重载都有一个可选参数``strict`` （即``subdivideIn(slices: SlicesCount,"
" strict: Boolean = "
"true)``）。如果“strict”为“true”，则如果输入无法分成相等的部分，则会出现错误。如果设置为“false”，最后一个元素可能小于其他（相同大小）元素。"
#: ../../SpinalHDL/Data types/bits.rst:348
msgid "Misc"
msgstr "杂项"
#: ../../SpinalHDL/Data types/bits.rst:350
msgid ""
"In contrast to the bit extraction operations listed above it's not possible "
"to use the return values to assign to the original signal."
msgstr "与上面列出的位提取操作相反，不可能使用返回值分配给原始信号。"
#: ../../SpinalHDL/Data types/bits.rst:360
msgid "x.getWidth"
msgstr "x.getWidth"
#: ../../SpinalHDL/Data types/bits.rst:361
msgid "Return bitcount"
msgstr "返回位数"
#: ../../SpinalHDL/Data types/bits.rst:362 types/bits.rst:371
msgid "Int"
msgstr "INT"
#: ../../SpinalHDL/Data types/bits.rst:363
msgid "x.bitsRange"
msgstr "x.bitsRange"
#: ../../SpinalHDL/Data types/bits.rst:364
msgid "Return the range (0 to x.high)"
msgstr "返回范围（0 到 x.high）"
#: ../../SpinalHDL/Data types/bits.rst:365 types/bits.rst:368
msgid "Range"
msgstr "范围"
#: ../../SpinalHDL/Data types/bits.rst:366
msgid "x.valueRange"
msgstr "x.valueRange"
#: ../../SpinalHDL/Data types/bits.rst:367
msgid ""
"Return the range of minimum to maximum x values, interpreted as an unsigned "
"integer (0 to 2 \\*\\* width - 1)."
msgstr "返回最小到最大 x 值的范围，解释为无符号整数（0 到 2 \\*\\* 宽度 - 1）。"
#: ../../SpinalHDL/Data types/bits.rst:369
msgid "x.high"
msgstr "x.高"
#: ../../SpinalHDL/Data types/bits.rst:370
#, fuzzy
msgid "Return the index of the MSB (highest allowed zero-based index for x)"
msgstr "返回 MSB 的索引（x 允许的最高从零开始的索引）"
#: ../../SpinalHDL/Data types/bits.rst:372
#, fuzzy
msgid "x.reversed"
msgstr "x.反转"
#: ../../SpinalHDL/Data types/bits.rst:373
msgid "Return a copy of x with reverse bit order, MSB<>LSB are mirrored."
msgstr "返回 x 的副本，其位顺序相反，MSB<>LSB 被镜像。"
#: ../../SpinalHDL/Data types/bits.rst:375
msgid "x ## y"
msgstr "x##y"
#: ../../SpinalHDL/Data types/bits.rst:376
msgid "Concatenate, x->high, y->low"
msgstr "连接，x->高，y->低"
#: ../../SpinalHDL/Data types/bits.rst:377
msgid "Bits(w(x) + w(y) bits)"
msgstr "位（w(x) + w(y) 位）"
#: ../../SpinalHDL/Data types/bits.rst:378
#, fuzzy
msgid "x #* n"
msgstr "x #* n"
#: ../../SpinalHDL/Data types/bits.rst:379
msgid "Repeat x n-times"
msgstr "重复 x n 次"
#: ../../SpinalHDL/Data types/bits.rst:380
#, fuzzy
msgid "Bits(w(x) * n bits)"
msgstr "位(w(x) * n 位)"
#: ../../SpinalHDL/Data types/bits.rst:381
msgid "x.resize(y)"
msgstr "x.调整大小(y)"
#: ../../SpinalHDL/Data types/bits.rst:382
#, fuzzy
msgid ""
"Return a resized representation of x, if enlarged, it is extended with zero "
"padding at MSB as necessary, y: Int"
msgstr "返回 x 的调整大小表示，如果放大，则根据需要在 MSB 处用零填充进行扩展，y：Int"
#: ../../SpinalHDL/Data types/bits.rst:384
msgid "Bits(y bits)"
msgstr "比特(y比特)"
#: ../../SpinalHDL/Data types/bits.rst:385
msgid "x.resized"
msgstr "x.调整大小"
#: ../../SpinalHDL/Data types/bits.rst:386
msgid ""
"Return a version of x which is allowed to be automatically resized were "
"needed.  The resize operation is deferred until the point of assignment "
"later. The resize may widen or truncate, retaining the LSB."
msgstr "返回一个允许自动调整大小的 x 版本。调整大小操作被推迟到稍后的分配点。调整大小可能会加宽或截断，但保留 LSB。"
#: ../../SpinalHDL/Data types/bits.rst:390
msgid "x.resizeLeft(x)"
msgstr "x.resizeLeft(x)"
#: ../../SpinalHDL/Data types/bits.rst:391
#, fuzzy
msgid ""
"Resize by keeping MSB at the same place, x:Int The resize may widen or "
"truncate, retaining the MSB."
msgstr "通过将 MSB 保留在同一位置来调整大小，x:Int 调整大小可能会加宽或截断，同时保留 MSB。"
#: ../../SpinalHDL/Data types/bits.rst:394
msgid "x.getZero"
msgstr "x.getZero"
#: ../../SpinalHDL/Data types/bits.rst:395
msgid ""
"Return a new instance of Bits that is assigned a constant value of zeros the"
" same width as x."
msgstr "返回 Bits 的新实例，该实例被分配了与 x 宽度相同的常量零值。"
#: ../../SpinalHDL/Data types/bits.rst:396
#, fuzzy
msgid "Bits(0, w(x) bits)"
msgstr "位（0，w(x) 位）"
#: ../../SpinalHDL/Data types/bits.rst:397
msgid "x.getAllTrue"
msgstr "x.getAllTrue"
#: ../../SpinalHDL/Data types/bits.rst:398
msgid ""
"Return a new instance of Bits that is assigned a constant value of ones the "
"same width as x."
msgstr "返回 Bits 的新实例，该实例被分配了与 x 宽度相同的常量值。"
#: ../../SpinalHDL/Data types/bits.rst:399
#, fuzzy
msgid "Bits(w(x) bits).setAll()"
msgstr "位(w(x)位).setAll()"
#: ../../SpinalHDL/Data types/bits.rst:402
#, fuzzy
msgid ""
"`validRange` can only be used for types where the minimum and maximum values"
" fit into a signed 32-bit integer. (This is a limitation given by the Scala "
"``scala.collection.immutable.Range`` type which uses `Int`)"
msgstr ""
"`validRange` 只能用于最小值和最大值适合有符号 32 位整数的类型。 （这是 Scala "
"``scala.collection.immutable.Range`` 类型使用 `Int` 给出的限制）"
#: ../../SpinalHDL/Data types/bits.rst:424
msgid "MaskedLiteral"
msgstr "蒙面文字"
#: ../../SpinalHDL/Data types/bits.rst:426
#, fuzzy
msgid ""
"MaskedLiteral values are bit vectors with don't care values denoted with "
"``-``. They can be used for direct comparison or for ``switch`` statements "
"and ``mux`` es."
msgstr "MaskedLiteral 值是位向量，不关心值用“-”表示。它们可用于直接比较或用于“switch”语句和“mux”es。"
#~ msgid "Create a BitVector, bits count is inferred"
#~ msgstr "Create a BitVector, bits count is inferred"
#~ msgid "x(y)"
#~ msgstr "x(y)"
#~ msgid "Readbit, y: Int/UInt"
#~ msgstr "读取位，y：Int/UInt"
#~ msgid "Read bitfield, offset: UInt, width: Int"
#~ msgstr "读取位域，偏移量：UInt，宽度：Int"
#~ msgid "x(y) := z"
#~ msgstr "x(y) := z"
#~ msgid "Assign bits, y: Int/UInt"
#~ msgstr "分配位，y：Int/UInt"
#~ msgid "x(offset, width bits) := z"
#~ msgstr "x(偏移量，宽度位) := z"
#~ msgid "Assign bitfield, offset: UInt, width: Int"
#~ msgstr "分配位域，偏移量：UInt，宽度：Int"
#~ msgid "x(\\ :ref:`range <range>`\\ ) := z"
#~ msgstr "x(\\ :ref:`范围 <范围>`\\ ) := z"
#~ msgid "Assign a range of bit. Ex : myBits(4 downto 2) := B\"010\""
#~ msgstr "指定一个位范围。例如：myBits(4 downto 2) := B\"010\""
#~ msgid "Return the most significant bit"
#~ msgstr "返回最高有效位"
#~ msgid "Return the least significant bit"
#~ msgstr "返回最低有效位"
#~ msgid "Vec(Bits, w(x)/y)"
#~ msgstr "Vec(位，w(x)/y)"
#~ msgid ""
#~ "Return a version of x which is allowed to be automatically resized were "
#~ "needed"
#~ msgstr "返回一个允许自动调整大小的 x 版本"

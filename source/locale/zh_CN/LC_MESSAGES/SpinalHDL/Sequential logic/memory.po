msgid ""
msgstr ""
"Project-Id-Version: SpinalHDLReport-Msgid-Bugs-To:POT-Creation-Date:2023-12-"
"01 11:48+0800PO-Revision-Date:YEAR-MO-DA HO:MI+ZONELast-Translator:FULL NAME "
"<EMAIL@ADDRESS>Language:zh_CNLanguage-Team:zh_CN <LL@li.org>Plural-"
"Forms:nplurals=1; plural=0;MIME-Version:1.0Content-Type:text/plain; "
"charset=UTF-8\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESSPOT-Creation-Date:2023-12-02 00:23+0800PO-"
"Revision-Date:YEAR-MO-DA HO:MI+ZONELast-Translator:FULL NAME <EMAIL@ADDRESS"
">Language-Team:LANGUAGE <LL@li.org>MIME-Version:1.0Content-Type:text/plain; "
"charset=UTF-8\n"
"PO-Revision-Date: 2023-12-02 14:47+0000\n"
"Last-Translator: Readon <xydarcher@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"spinaldoc-rtd/spinalhdlsequential-logicmemory/zh_Hans/>\n"
"Language: zh_CN\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bitGenerated-By:Babel 2.13.1\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 5.3-dev\n"

#: ../../SpinalHDL/Sequential logic/memory.rst:2
#, fuzzy
msgid "RAM/ROM Memory"
msgstr "内存/只读存储器"

#: ../../SpinalHDL/Sequential logic/memory.rst:4
msgid ""
"To create a memory in SpinalHDL, the ``Mem`` class should be used. It allows"
" you to define a memory and add read and write ports to it."
msgstr "要在 SpinalHDL 中创建内存，应使用“Mem”类。它允许您定义内存并向其添加读写端口。"

#: ../../SpinalHDL/Sequential logic/memory.rst:7
msgid "The following table shows how to instantiate a memory:"
msgstr "下表显示了如何实例化内存："

#: ../../SpinalHDL/Sequential logic/memory.rst:13 logic/memory.rst:40
#: logic/memory.rst:161
msgid "Syntax"
msgstr "语法"

#: ../../SpinalHDL/Sequential logic/memory.rst:14 logic/memory.rst:41
#: logic/memory.rst:140 logic/memory.rst:162 logic/memory.rst:227
msgid "Description"
msgstr "描述"

#: ../../SpinalHDL/Sequential logic/memory.rst:15
msgid "``Mem(type : Data, size : Int)``"
msgstr "``Mem（类型：数据，大小：Int）``"

#: ../../SpinalHDL/Sequential logic/memory.rst:16
msgid "Create a RAM"
msgstr "创建内存"

#: ../../SpinalHDL/Sequential logic/memory.rst:17
msgid "``Mem(type : Data, initialContent : Array[Data])``"
msgstr "``Mem（类型：数据，初始内容：数组[数据]）``"

#: ../../SpinalHDL/Sequential logic/memory.rst:18
msgid ""
"Create a ROM. If your target is an FPGA, because the memory can be inferred "
"as a block ram, you can still create write ports on it."
msgstr "创建一个 ROM。如果您的目标是 FPGA，因为内存可以推断为块 RAM，您仍然可以在其上创建写入端口。"

#: ../../SpinalHDL/Sequential logic/memory.rst:22
msgid ""
"If you want to define a ROM, elements of the ``initialContent`` array should"
" only be literal values (no operator, no resize functions). There is an "
"example :ref:`here <sinus_rom>`."
msgstr ""
"如果你想定义一个 ROM，``initialContent`` "
"数组的元素应该只是文字值（没有运算符，没有调整大小函数）。这里有一个例子:ref:`<sinus_rom>`。"

#: ../../SpinalHDL/Sequential logic/memory.rst:25
msgid "To give a RAM initial values, you can also use the ``init`` function."
msgstr "要给 RAM 初始值，您还可以使用“init”函数。"

#: ../../SpinalHDL/Sequential logic/memory.rst:28
msgid ""
"Write mask width is flexible, and subdivide the memory word in as many "
"slices of equal width as the width of the mask. For instance if you have a "
"32 bits memory word and provide a 4 bits mask then it will be a byte mask. "
"If you provide a as many mask bits than you have word bits, then it is a bit"
" mask."
msgstr ""
"Write mask width is flexible, and subdivide the memory word in as many "
"slices of equal width as the width of the mask. For instance if you have a "
"32 bits memory word and provide a 4 bits mask then it will be a byte mask. "
"If you provide a as many mask bits than you have word bits, then it is a bit"
" mask."

#: ../../SpinalHDL/Sequential logic/memory.rst:32
msgid ""
"Manipulation of ``Mem`` is possible in simulation, see section :ref:`Load "
"and Store of Memory in Simulation <simulation_of_memory>`."
msgstr "在模拟中可以对“Mem”进行操作，请参阅“模拟中内存的加载和存储<simulation_of_memory>”部分。"

#: ../../SpinalHDL/Sequential logic/memory.rst:34
msgid "The following table show how to add access ports on a memory :"
msgstr "下表显示了如何在内存上添加访问端口："

#: ../../SpinalHDL/Sequential logic/memory.rst:42
msgid "Return"
msgstr "返回值"

#: ../../SpinalHDL/Sequential logic/memory.rst:43
msgid "mem(address) := data"
msgstr "mem(地址) := 数据"

#: ../../SpinalHDL/Sequential logic/memory.rst:44
msgid "Synchronous write"
msgstr "同步写入"

#: ../../SpinalHDL/Sequential logic/memory.rst:46
msgid "mem(x)"
msgstr "内存（x）"

#: ../../SpinalHDL/Sequential logic/memory.rst:47
msgid "Asynchronous read"
msgstr "异步读取"

#: ../../SpinalHDL/Sequential logic/memory.rst:48 logic/memory.rst:63
#: logic/memory.rst:71 logic/memory.rst:84
msgid "T"
msgstr "时间"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "mem.write("
msgstr "内存.write("

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "address"
msgstr "地址"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "data"
msgstr "数据"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "[enable]"
msgstr "[使能够]"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "[mask]"
msgstr "[面具]"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid ")"
msgstr "）"

#: ../../SpinalHDL/Sequential logic/memory.rst
#, fuzzy
msgid "Synchronous write with an optional mask."
msgstr "使用可选掩码进行同步写入。"

#: ../../SpinalHDL/Sequential logic/memory.rst
#, fuzzy
msgid ""
"If no enable is specified, it's automatically inferred from the conditional "
"scope where this function is called"
msgstr "如果未指定启用，则会自动从调用此函数的条件范围中推断出"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "mem.readAsync("
msgstr "mem.readAsync("

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "[readUnderWrite]"
msgstr "[读下写]"

#: ../../SpinalHDL/Sequential logic/memory.rst:62
msgid "Asynchronous read with an optional read-under-write policy"
msgstr "具有可选的读下写策略的异步读取"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "mem.readSync("
msgstr "内存.readSync("

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "[clockCrossing]"
msgstr "[时钟穿越]"

#: ../../SpinalHDL/Sequential logic/memory.rst:70
msgid ""
"Synchronous read with an optional enable, read-under-write policy, and "
"``clockCrossing`` mode"
msgstr ""
"Synchronous read with an optional enable, read-under-write policy, and "
"``clockCrossing`` mode"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "mem.readWriteSync("
msgstr "mem.readWriteSync("

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "enable"
msgstr "使能"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "write"
msgstr "写"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "Infer a read/write port."
msgstr "推断读/写端口。"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "``data`` is written when ``enable && write``."
msgstr "当“enable && write”时写入“data”。"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "Return the read data, the read occurs when ``enable`` is true"
msgstr "返回读取的数据，当``enable``为true时发生读取"

#: ../../SpinalHDL/Sequential logic/memory.rst:88
msgid ""
"If for some reason you need a specific memory port which is not implemented "
"in Spinal, you can always abstract over your memory by specifying a BlackBox"
" for it."
msgstr "如果由于某种原因您需要一个未在 Spinal 中实现的特定内存端口，您始终可以通过为其指定 BlackBox 来抽象您的内存。"

#: ../../SpinalHDL/Sequential logic/memory.rst:91
msgid ""
"Memory ports in SpinalHDL are not inferred, but are explicitly defined. You "
"should not use coding templates like in VHDL/Verilog to help the synthesis "
"tool to infer memory."
msgstr "SpinalHDL 中的内存端口不是推断的，而是明确定义的。您不应使用 VHDL/Verilog 等编码模板来帮助综合工具推断内存。"

#: ../../SpinalHDL/Sequential logic/memory.rst:93
msgid "Here is a example which infers a simple dual port ram (32 bits * 256):"
msgstr "下面是一个推断简单双端口 RAM（32 位 * 256）的示例："

#: ../../SpinalHDL/Sequential logic/memory.rst:111
msgid "Synchronous enable quirk"
msgstr "同步启用怪癖"

#: ../../SpinalHDL/Sequential logic/memory.rst:113
msgid ""
"When enable signals are used in a block guarded by a conditional block like "
"`when`, only the enable signal will be generated as the access condition: "
"the `when` condition is ignored."
msgstr "当使能信号用于由“when”等条件块保护的块中时，只会生成使能信号作为访问条件：“when”条件将被忽略。"

#: ../../SpinalHDL/Sequential logic/memory.rst:123
msgid ""
"In the example above the condition `cond` will not be elaborated. Prefer to "
"include the condition `cond` in the enable signal directly as below."
msgstr "上面的例子中条件`cond`就不详细说明了。最好直接在使能信号中包含条件“cond”，如下所示。"

#: ../../SpinalHDL/Sequential logic/memory.rst:131
msgid "Read-under-write policy"
msgstr "读写策略"

#: ../../SpinalHDL/Sequential logic/memory.rst:133
msgid ""
"This policy specifies how a read is affected when a write occurs in the same"
" cycle to the same address."
msgstr "此策略指定在同一周期内对同一地址发生写入时，读取将受到怎样的影响。"

#: ../../SpinalHDL/Sequential logic/memory.rst:139 logic/memory.rst:226
msgid "Kinds"
msgstr "种类"

#: ../../SpinalHDL/Sequential logic/memory.rst:141
msgid "``dontCare``"
msgstr "``不在乎``"

#: ../../SpinalHDL/Sequential logic/memory.rst:142
msgid "Don't care about the read value when the case occurs"
msgstr "发生这种情况时不用关心读取的值"

#: ../../SpinalHDL/Sequential logic/memory.rst:143
msgid "``readFirst``"
msgstr "``首先阅读``"

#: ../../SpinalHDL/Sequential logic/memory.rst:144
msgid "The read will get the old value (before the write)"
msgstr "读取将得到旧值（写入之前）"

#: ../../SpinalHDL/Sequential logic/memory.rst:145
msgid "``writeFirst``"
msgstr "``先写``"

#: ../../SpinalHDL/Sequential logic/memory.rst:146
msgid "The read will get the new value (provided by the write)"
msgstr "读取将得到新值（由写入提供）"

#: ../../SpinalHDL/Sequential logic/memory.rst:150
msgid ""
"The generated VHDL/Verilog is always in the ``readFirst`` mode, which is "
"compatible with ``dontCare`` but not with ``writeFirst``. To generate a "
"design that contains this kind of feature, you need to enable "
":ref:`automatic memory blackboxing <automatic_memory_blackboxing>`."
msgstr ""
"生成的 VHDL/Verilog "
"始终处于“readFirst”模式，该模式与“dontCare”兼容，但与“writeFirst”不兼容。要生成包含此类功能的设计，您需要启用:ref:`自动内存黑盒"
" <automatic_memory_blackboxing>`。"

#: ../../SpinalHDL/Sequential logic/memory.rst:153
msgid "Mixed-width ram"
msgstr "混合宽度内存"

#: ../../SpinalHDL/Sequential logic/memory.rst:155
msgid ""
"You can specify ports that access the memory with a width that is a power of"
" two fraction of the memory width using these functions:"
msgstr "您可以使用以下函数指定访问内存的端口，其宽度为内存宽度的二分之一次方："

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "mem.writeMixedWidth("
msgstr "mem.writeMixedWidth("

#: ../../SpinalHDL/Sequential logic/memory.rst:168
msgid "Similar to ``mem.write``"
msgstr "类似于“mem.write”"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "mem.readAsyncMixedWidth("
msgstr "mem.readAsyncMixedWidth("

#: ../../SpinalHDL/Sequential logic/memory.rst:174
msgid ""
"Similar to ``mem.readAsync``, but in place of returning the read value, it "
"drives the signal/object given as the ``data`` argument"
msgstr ""
"Similar to ``mem.readAsync``, but in place of returning the read value, it "
"drives the signal/object given as the ``data`` argument"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "mem.readSyncMixedWidth("
msgstr "mem.readSyncMixedWidth("

#: ../../SpinalHDL/Sequential logic/memory.rst:182
msgid ""
"Similar to ``mem.readSync``, but in place of returning the read value, it "
"drives the signal/object given as the ``data`` argument"
msgstr "与“mem.readSync”类似，但它不是返回读取值，而是驱动作为“data”参数给出的信号/对象"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "mem.readWriteSyncMixedWidth("
msgstr "mem.readWriteSyncMixedWidth("

#: ../../SpinalHDL/Sequential logic/memory.rst:192
msgid "Equivalent to ``mem.readWriteSync``"
msgstr "相当于“mem.readWriteSync”"

#: ../../SpinalHDL/Sequential logic/memory.rst:196
msgid ""
"As for read-under-write policy, to use this feature you need to enable "
":ref:`automatic memory blackboxing <automatic_memory_blackboxing>`, because "
"there is no universal VHDL/Verilog language template to infer mixed-width "
"ram."
msgstr ""
"至于读下写策略，要使用此功能，您需要启用自动内存黑盒 <automatic_memory_blackboxing>`，因为没有通用的 "
"VHDL/Verilog 语言模板来推断混合宽度 ram。"

#: ../../SpinalHDL/Sequential logic/memory.rst:201
msgid "Automatic blackboxing"
msgstr "Automatic blackboxing"

#: ../../SpinalHDL/Sequential logic/memory.rst:203
msgid ""
"Because it's impossible to infer all ram kinds by using regular "
"VHDL/Verilog, SpinalHDL integrates an optional automatic blackboxing system."
" This system looks at all memories present in your RTL netlist and replaces "
"them with blackboxes. Then the generated code will rely on third party IP to"
" provide the memory features, such as the read-during-write policy and "
"mixed-width ports."
msgstr ""
"由于使用常规 VHDL/Verilog 不可能推断所有 ram 类型，因此 SpinalHDL 集成了可选的自动黑盒系统。该系统会查看 RTL "
"网表中存在的所有内存，并用黑盒替换它们。然后生成的代码将依赖第三方IP来提供内存功能，例如read-during-write策略和混合宽度端口。"

#: ../../SpinalHDL/Sequential logic/memory.rst:205
msgid ""
"Here is an example of how to enable blackboxing of memories by default:"
msgstr ""
"Here is an example of how to enable blackboxing of memories by default:"

#: ../../SpinalHDL/Sequential logic/memory.rst:215
msgid ""
"If the standard blackboxing tools don't do enough for your design, do not "
"hesitate to create a `Github issue "
"<https://github.com/SpinalHDL/SpinalHDL/issues>`_. There is also a way to "
"create your own blackboxing tool."
msgstr ""
"如果标准黑盒工具不足以满足您的设计需求，请毫不犹豫地创建“Github 问题 "
"<https://github.com/SpinalHDL/SpinalHDL/issues>”_。还有一种方法可以创建您自己的黑盒工具。"

#: ../../SpinalHDL/Sequential logic/memory.rst:218
msgid "Blackboxing policy"
msgstr "黑盒政策"

#: ../../SpinalHDL/Sequential logic/memory.rst:220
msgid ""
"There are multiple policies that you can use to select which memory you want"
" to blackbox and also what to do when the blackboxing is not feasible:"
msgstr "您可以使用多种策略来选择要黑盒的内存以及黑盒不可行时要执行的操作："

#: ../../SpinalHDL/Sequential logic/memory.rst:228
msgid "``blackboxAll``"
msgstr "``黑盒全部``"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "Blackbox all memory."
msgstr "Blackbox all memory."

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "Throw an error on unblackboxable memory"
msgstr "对不可黑盒内存抛出错误"

#: ../../SpinalHDL/Sequential logic/memory.rst:231
msgid "``blackboxAllWhatsYouCan``"
msgstr "``blackboxAllWhatsYouCan``"

#: ../../SpinalHDL/Sequential logic/memory.rst:232
msgid "Blackbox all memory that is blackboxable"
msgstr "黑盒所有可黑盒的内存"

#: ../../SpinalHDL/Sequential logic/memory.rst:233
msgid "``blackboxRequestedAndUninferable``"
msgstr "``blackboxRequestedAndUninferable``"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid ""
"Blackbox memory specified by the user and memory that is known to be "
"uninferable (mixed-width, ...)."
msgstr "用户指定的黑盒内存和已知不可推断的内存（混合宽度，...）。"

#: ../../SpinalHDL/Sequential logic/memory.rst:236
msgid "``blackboxOnlyIfRequested``"
msgstr "``blackboxOnlyIfRequested``"

#: ../../SpinalHDL/Sequential logic/memory.rst
msgid "Blackbox memory specified by the user"
msgstr "用户指定的黑盒内存"

#: ../../SpinalHDL/Sequential logic/memory.rst:241
msgid ""
"To explicitly set a memory to be blackboxed, you can use its "
"``generateAsBlackBox`` function."
msgstr "要显式地将内存设置为黑盒，您可以使用其“generateAsBlackBox”函数。"

#: ../../SpinalHDL/Sequential logic/memory.rst:248
msgid ""
"You can also define your own blackboxing policy by extending the "
"``MemBlackboxingPolicy`` class."
msgstr ""
"You can also define your own blackboxing policy by extending the "
"``MemBlackboxingPolicy`` class."

#: ../../SpinalHDL/Sequential logic/memory.rst:251
msgid "Standard memory blackboxes"
msgstr "标准内存黑匣子"

#: ../../SpinalHDL/Sequential logic/memory.rst:253
msgid ""
"Shown below are the VHDL definitions of the standard blackboxes used in "
"SpinalHDL:"
msgstr "下面显示的是 SpinalHDL 中使用的标准黑盒的 VHDL 定义："

#: ../../SpinalHDL/Sequential logic/memory.rst:365
msgid ""
"As you can see, blackboxes have a technology parameter. To set it, you can "
"use the ``setTechnology`` function on the corresponding memory. There are "
"currently 4 kinds of technologies possible:"
msgstr "正如你所看到的，黑匣子有一个技术参数。要设置它，您可以在相应的内存上使用“setTechnology”函数。目前有4种可能的技术："

#: ../../SpinalHDL/Sequential logic/memory.rst:368
msgid "``auto``"
msgstr "``自动``"

#: ../../SpinalHDL/Sequential logic/memory.rst:369
msgid "``ramBlock``"
msgstr "``内存块``"

#: ../../SpinalHDL/Sequential logic/memory.rst:370
msgid "``distributedLut``"
msgstr "``分布式Lut``"

#: ../../SpinalHDL/Sequential logic/memory.rst:371
msgid "``registerFile``"
msgstr "``注册文件``"

#: ../../SpinalHDL/Sequential logic/memory.rst:373
msgid ""
"Blackboxing can insert HDL attributes if ``SpinalConfig#setDevice(Device)`` "
"has been configured for your device-vendor."
msgstr ""
"如果已为您的设备供应商配置了“SpinalConfig#setDevice(Device)”，则 Blackboxing 可以插入 HDL 属性。"

#: ../../SpinalHDL/Sequential logic/memory.rst:376
msgid "The resulting HDL attributes might look like:"
msgstr "生成的 HDL 属性可能如下所示："

#: ../../SpinalHDL/Sequential logic/memory.rst:383
msgid ""
"SpinalHDL tries to support many common memory types provided by well known "
"vendors and devices, however this is an ever moving landscape and project "
"requirements can be very specific in this area."
msgstr "SpinalHDL 尝试支持知名供应商和设备提供的许多常见内存类型，但是这是一个不断变化的领域，并且该领域的项目要求可能非常具体。"

#: ../../SpinalHDL/Sequential logic/memory.rst:387
msgid ""
"If this is important to your design flow then check the output HDL for the "
"expected attributes/generic insertion, while consulting your vendor's "
"platform documentation."
msgstr "如果这对您的设计流程很重要，请检查输出 HDL 是否有预期的属性/通用插入，同时查阅供应商的平台文档。"

#: ../../SpinalHDL/Sequential logic/memory.rst:391
msgid ""
"HDL attributes can also be added manually using the `addAttribute()` "
":ref:`addAttribute <vhdl-and-verilog-attributes>` mechanism."
msgstr ""
"HDL 属性也可以使用 `addAttribute()` :ref:`addAttribute <vhdl-and-verilog-"
"attributes>` 机制手动添加。"

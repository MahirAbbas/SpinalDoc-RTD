# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, SpinalHDL
# This file is distributed under the same license as the SpinalHDL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SpinalHDL \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-12-01 11:48+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/SpinalHDL/Semantic/rules.rst:3
msgid "Rules"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:6
msgid "Introduction"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:8
msgid "The semantics behind SpinalHDL are important to learn, so that you understand what is really happening behind the scenes, and how to control it."
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:10
msgid "These semantics are defined by multiple rules:"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:12
msgid "Signals and registers are operating concurrently with each other (parallel behavioral, as in VHDL and Verilog)"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:13
msgid "An assignment to a combinational signal is like expressing a rule which is always true"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:14
msgid "An assignment to a register is like expressing a rule which is applied on each cycle of its clock domain"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:15
msgid "For each signal, the last valid assignment wins"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:16
msgid "Each signal and register can be manipulated as an object during hardware elaboration in a `OOP <https://en.wikipedia.org/wiki/Object-oriented_programming>`_ manner"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:19
msgid "Concurrency"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:21
msgid "The order in which you assign each combinational or registered signal has no behavioral impact."
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:23
msgid "For example, both of the following pieces of code are equivalent:"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:32
msgid "This is equivalent to:"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:41
msgid "More generally, when you use the ``:=`` assignment operator, it's like specifying a new rule for the left side signal/register."
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:44
msgid "Last valid assignment wins"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:46
msgid "If a combinational signal or register is assigned multiple times, the last valid one wins."
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:48
msgid "As an example:"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:63
msgid "This will produce the following truth table:"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:68
msgid "x"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:69
msgid "y"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:70
msgid "=>"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:71
msgid "result"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:72
#: ../../source/SpinalHDL/Semantic/rules.rst:73
#: ../../source/SpinalHDL/Semantic/rules.rst:76
#: ../../source/SpinalHDL/Semantic/rules.rst:81
msgid "False"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:75
#: ../../source/SpinalHDL/Semantic/rules.rst:79
msgid "1"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:77
#: ../../source/SpinalHDL/Semantic/rules.rst:80
#: ../../source/SpinalHDL/Semantic/rules.rst:84
#: ../../source/SpinalHDL/Semantic/rules.rst:85
msgid "True"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:83
msgid "2"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:87
msgid "3"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:91
msgid "Signal and register interactions with Scala (OOP reference + Functions)"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:93
msgid "In SpinalHDL, each hardware element is modeled by a class instance. This means you can manipulate instances by using their references, such as passing them as arguments to a function."
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:95
msgid "As an example, the following code implements a register which is incremented when ``inc`` is True and cleared when ``clear`` is True (``clear`` has priority over ``inc``) :"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:109
msgid "You can implement exactly the same functionality by mixing the previous example with a function that assigns to ``counter``:"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:127
msgid "You can also integrate the conditional check inside the function:"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:143
msgid "And also specify what should be assigned to the function:"
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:159
msgid "All of the previous examples are strictly equivalent both in their generated RTL and also in the SpinalHDL compiler's perspective. This is because SpinalHDL only cares about the Scala runtime and the objects instantiated there, it doesn't care about the Scala syntax itself."
msgstr ""

#: ../../source/SpinalHDL/Semantic/rules.rst:162
msgid "In other words, from a generated RTL generation / SpinalHDL perspective, when you use functions in Scala which generate hardware, it is like the function was inlined. This is also true case for Scala loops, as they will appear in unrolled form in the generated RTL."
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, SpinalHDL
# This file is distributed under the same license as the SpinalHDL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SpinalHDL \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-12-01 11:48+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:3
msgid "SpinalHDL internal datamodel"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:10
msgid "Introduction"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:12
msgid "This page document the internal data structure user by SpinalHDL to store and modify the netlist described by the user through the SpinalHDL API."
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:15
msgid "General structure"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:17
msgid "The following diagrams follow the UML nomenclature :"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:19
msgid "A link with a white arrow mean \"base extend target\""
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:20
msgid "A link with a black diamond mean \"base contains target\""
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:21
msgid "A link with a white diamond mean \"base has a reference to target\""
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:22
msgid "The * symbole mean \"multiple\""
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:24
msgid "Most of the data structure is stored via some double linked list to ease the insertion and the removal of elements."
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:26
msgid "There is a diagram of the global data structure :"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:31
msgid "And here more details about the Statement class :"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:36
msgid "So in general, if a element of the datamodel use some other Expression or Statements, that element will have some functions to iterate over those usages. For instance, each Expression has a `foreachExpression` function."
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:38
msgid "When using those iterating functions, you are allowed to remove the current element of the tree."
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:40
msgid "Also asside the foreachXXX, which \"only\" iterate one level deep, there is often a walkXXX which will iterate recursively. So for instance myExpression.walkExpression on ((a+b)+c)+d will go through the whole tree of adders."
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:42
msgid "There is also utilities as myExpression.remapExpressions(Expression => Expression) which will iterate over all used expression of myExpression, and change it for your returned one."
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:44
msgid "More generaly, most of the graph checks and transformations done by SpinalHDL are located in <https://github.com/SpinalHDL/SpinalHDL/blob/dev/core/src/main/scala/spinal/core/internals/Phase.scala>"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:47
msgid "Exploring the datamodel"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:49
msgid "Here is an example which find all adders of the netlist without using \"shortcuts\" :"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:109
msgid "Which will produces :"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:127
msgid "Note that in many case, there is shortcuts. All the recursive stuff above could have been remplaced by a single :"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:141
msgid "Compilation Phases"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:143
msgid "Here are all the default phases (in order) used to modify / check / generate verilog from a toplevel component :"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:145
msgid "<https://github.com/SpinalHDL/SpinalHDL/blob/ec8cd9f513566b43cbbdb08d0df4dee1f0fee655/core/src/main/scala/spinal/core/internals/Phase.scala#L2487>"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:147
msgid "If as a use you add a new compilation phase using  SpinalConfig.addTransformationPhase(new MyPhase()), then the phase will be added directly after the user component elaboration (so quite early). At that time, you can still use the whole SpinalHDL user API to add elements into the netlist."
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:149
msgid "If you use the SpinalConfig.phasesInserters api, then you will have to be carefull to only modify the netlist in a way which is compatible with the phases which were already executed. For instance, if you insert you phase after the `PhaseInferWidth`, then you have to specify the width of each nodes you insert."
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:152
msgid "Modifying a netlist as a user without plugins"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:154
msgid "There is quite a few user API which allow to modify things durring the user elaboration time :"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:156
msgid "mySignal.removeAssignments : Will remove all previous `:=` affecting the given signal"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:157
msgid "mySignal.removeStatement : Will void the existance of the signal"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:158
msgid "mySignal.setAsDirectionLess : Will turn a in / out signal into a internal signal"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:159
msgid "mySignal.setName : Enforce a given name on a signal (there is many other variants)"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:160
msgid "mySubComponent.mySignal.pull() : Will provide a readable copy of the given signal, even if that signal is somewhere else in the hierarchy"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:161
msgid "myComponent.rework\\{ myCode \\} : Execute `myCode` in the context of `myComponent`, allowing modifying it with the user API"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:163
msgid "For instance, the following code will rework a toplevel component to insert a 3 stages shift register on each input / output of the component. (Usefull for synthesis tests)"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:187
msgid "Which can be used the following way :"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:193
msgid "Here is an function, which allow to execute the `body` code as if nothing ever existed in the current component. This can be used for example to define new signals clean of the current conditional scope (when/switch)"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:223
msgid "This kind of functionnality is for instance used in the VexRiscv pipeline to dynamicaly create things."
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:227
msgid "User space netlist analysis"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:229
msgid "The SpinalHDL datamodel is also readable during usertime elaboration. Here is is an example which will find the shortest logical path (in therms of clock cycles) to travel through a list of signals. In the given case, it is to analyse the latency of the VexRiscv FPU design."
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:243
msgid "Here you can find the implementation of that LatencyAnalysis tool : <https://github.com/SpinalHDL/SpinalHDL/blob/3b87c898cb94dc08456b4fe2b1e8b145e6c86f63/lib/src/main/scala/spinal/lib/Utils.scala#L620>"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:248
msgid "Enumerating every ClockDomain used"
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:250
msgid "So here it is done after the elaboration using the SpinalHDL report."
msgstr ""

#: ../../source/SpinalHDL/Developers area/spinalhdl_datamodel.rst:286
msgid "Will print out"
msgstr ""

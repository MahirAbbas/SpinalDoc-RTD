# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, SpinalHDL
# This file is distributed under the same license as the SpinalHDL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SpinalHDL \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-12-01 11:48+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/SpinalHDL/Sequential logic/memory.rst:5
msgid "RAM/ROM"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:8
#: ../../source/SpinalHDL/Sequential logic/memory.rst:19
#: ../../source/SpinalHDL/Sequential logic/memory.rst:43
#: ../../source/SpinalHDL/Sequential logic/memory.rst:164
msgid "Syntax"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:10
msgid "To create a memory in SpinalHDL, the ``Mem`` class should be used. It allows you to define a memory and add read and write ports to it."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:13
msgid "The following table shows how to instantiate a memory:"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:20
#: ../../source/SpinalHDL/Sequential logic/memory.rst:44
#: ../../source/SpinalHDL/Sequential logic/memory.rst:143
#: ../../source/SpinalHDL/Sequential logic/memory.rst:165
#: ../../source/SpinalHDL/Sequential logic/memory.rst:230
msgid "Description"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:21
msgid "``Mem(type : Data, size : Int)``"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:22
msgid "Create a RAM"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:23
msgid "``Mem(type : Data, initialContent : Array[Data])``"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:24
msgid "Create a ROM. If your target is an FPGA, because the memory can be inferred as a block ram, you can still create write ports on it."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:28
msgid "If you want to define a ROM, elements of the ``initialContent`` array should only be literal values (no operator, no resize functions). There is an example :ref:`here <sinus_rom>`."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:31
msgid "To give a RAM initial values, you can also use the ``init`` function."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:34
msgid "Write mask width is flexible, and subdivide the memory word in as many slices of equal width as the width of the mask. For instance if you have a 32 bits memory word and provide a 4 bits mask then it will be a byte mask. If you provide a as many mask bits than you have word bits, then it is a bit mask."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:37
msgid "The following table show how to add access ports on a memory :"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:45
msgid "Return"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:46
msgid "mem(address) := data"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:47
msgid "Synchronous write"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:49
msgid "mem(x)"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:50
msgid "Asynchronous read"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:51
#: ../../source/SpinalHDL/Sequential logic/memory.rst:66
#: ../../source/SpinalHDL/Sequential logic/memory.rst:74
#: ../../source/SpinalHDL/Sequential logic/memory.rst:87
msgid "T"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "mem.write("
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "address"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "data"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "[enable]"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "[mask]"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid ")"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:58
msgid "Synchronous write with an optional mask. If no enable is specified, it's automatically inferred from the conditional scope where this function is called"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "mem.readAsync("
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "[readUnderWrite]"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:65
msgid "Asynchronous read with an optional read-under-write policy"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "mem.readSync("
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "[clockCrossing]"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:73
msgid "Synchronous read with an optional enable, read-under-write policy, and ``clockCrossing`` mode"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "mem.readWriteSync("
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "enable"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "write"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "Infer a read/write port."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "``data`` is written when ``enable && write``."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "Return the read data, the read occurs when ``enable`` is true"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:91
msgid "If for some reason you need a specific memory port which is not implemented in Spinal, you can always abstract over your memory by specifying a BlackBox for it."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:94
msgid "Memory ports in SpinalHDL are not inferred, but are explicitly defined. You should not use coding templates like in VHDL/Verilog to help the synthesis tool to infer memory."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:96
msgid "Here is a example which infers a simple dual port ram (32 bits * 256):"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:114
msgid "Synchronous enable quirk"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:116
msgid "When enable signals are used in a block guarded by a conditional block like `when`, only the enable signal will be generated as the access condition: the `when` condition is ignored."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:126
msgid "In the example above the condition `cond` will not be elaborated. Prefer to include the condition `cond` in the enable signal directly as below."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:134
msgid "Read-under-write policy"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:136
msgid "This policy specifies how a read is affected when a write occurs in the same cycle to the same address."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:142
#: ../../source/SpinalHDL/Sequential logic/memory.rst:229
msgid "Kinds"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:144
msgid "``dontCare``"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:145
msgid "Don't care about the read value when the case occurs"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:146
msgid "``readFirst``"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:147
msgid "The read will get the old value (before the write)"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:148
msgid "``writeFirst``"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:149
msgid "The read will get the new value (provided by the write)"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:153
msgid "The generated VHDL/Verilog is always in the ``readFirst`` mode, which is compatible with ``dontCare`` but not with ``writeFirst``. To generate a design that contains this kind of feature, you need to enable :ref:`automatic memory blackboxing <automatic_memory_blackboxing>`."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:156
msgid "Mixed-width ram"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:158
msgid "You can specify ports that access the memory with a width that is a power of two fraction of the memory width using these functions:"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "mem.writeMixedWidth("
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:171
msgid "Similar to ``mem.write``"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "mem.readAsyncMixedWidth("
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:177
msgid "Similar to ``mem.readAsync``, but in place of returning the read value, it drives the signal/object given as the ``data`` argument"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "mem.readSyncMixedWidth("
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:185
msgid "Similar to ``mem.readSync``, but in place of returning the read value, it drives the signal/object given as the ``data`` argument"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "mem.readWriteSyncMixedWidth("
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:195
msgid "Equivalent to ``mem.readWriteSync``"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:199
msgid "As for read-under-write policy, to use this feature you need to enable :ref:`automatic memory blackboxing <automatic_memory_blackboxing>`, because there is no universal VHDL/Verilog language template to infer mixed-width ram."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:204
msgid "Automatic blackboxing"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:206
msgid "Because it's impossible to infer all ram kinds by using regular VHDL/Verilog, SpinalHDL integrates an optional automatic blackboxing system. This system looks at all memories present in your RTL netlist and replaces them with blackboxes. Then the generated code will rely on third party IP to provide the memory features, such as the read-during-write policy and mixed-width ports."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:208
msgid "Here is an example of how to enable blackboxing of memories by default:"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:218
msgid "If the standard blackboxing tools don't do enough for your design, do not hesitate to create a `Github issue <https://github.com/SpinalHDL/SpinalHDL/issues>`_. There is also a way to create your own blackboxing tool."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:221
msgid "Blackboxing policy"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:223
msgid "There are multiple policies that you can use to select which memory you want to blackbox and also what to do when the blackboxing is not feasible:"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:231
msgid "``blackboxAll``"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "Blackbox all memory."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "Throw an error on unblackboxable memory"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:234
msgid "``blackboxAllWhatsYouCan``"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:235
msgid "Blackbox all memory that is blackboxable"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:236
msgid "``blackboxRequestedAndUninferable``"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "Blackbox memory specified by the user and memory that is known to be uninferable (mixed-width, ...)."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:239
msgid "``blackboxOnlyIfRequested``"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:0
msgid "Blackbox memory specified by the user"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:244
msgid "To explicitly set a memory to be blackboxed, you can use its ``generateAsBlackBox`` function."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:251
msgid "You can also define your own blackboxing policy by extending the ``MemBlackboxingPolicy`` class."
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:254
msgid "Standard memory blackboxes"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:256
msgid "Shown below are the VHDL definitions of the standard blackboxes used in SpinalHDL:"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:368
msgid "As you can see, blackboxes have a technology parameter. To set it, you can use the ``setTechnology`` function on the corresponding memory. There are currently 4 kinds of technologies possible:"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:371
msgid "``auto``"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:372
msgid "``ramBlock``"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:373
msgid "``distributedLut``"
msgstr ""

#: ../../source/SpinalHDL/Sequential logic/memory.rst:374
msgid "``registerFile``"
msgstr ""
